<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Jonhnny Weslley" />
  <meta name="dcterms.date" content="2014-12-09" />
  <title>Golang</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="../reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <link rel="stylesheet" href="../reveal.js/lib/css/solarized_dark.css"/>
    <link rel="stylesheet" href="../reveal.js/css/theme/solarized.css"/>
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
      }
    </script>
    <!--[if lt IE 9]>
    <script src="../reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Golang</h1>
    <h2 class="author">Jonhnny Weslley</h2>
    <h3 class="date">20/09/2014</h3>
</section>

<section><section id="golang" class="titleslide slide level1"><h1>Golang</h1></section><section id="o-que-é-go" class="slide level2">
<h1>O que é Go?</h1>
<ul>
<li>Linguagem de programação open-source</li>
<li>Compilada (compilação rápida)</li>
<li>Estaticamente tipada \o/</li>
<li>Cross-compilation (32-bit, 64-bit, ARM)
<ul>
<li>FreeBSD, Linux, Mac OS X, Windows e android (go 1.4)</li>
</ul></li>
<li>Garbage collector</li>
<li>Sistema de tipos simples</li>
<li>Possui primitivas de concorrência</li>
</ul>
</section><section id="origem" class="slide level2">
<h1>Origem</h1>
<ul>
<li>Criada pelo Google</li>
<li>Iniciada em 2007 por Robert Griesemer, Rob Pike e Ken Thompson.</li>
<li>Liberada em 2009 sob BSD-license</li>
<li>Versão 1.0 em Março de 2012</li>
</ul>
<figure>
<img src="images/gopher.jpg" alt="Gopher" /><figcaption>Gopher</figcaption>
</figure>
</section><section id="quem-usa" class="slide level2">
<h1>Quem usa?</h1>
<ul>
<li>Google (YouTube, dl.google.com, ...)</li>
<li>dotCloud (Docker)</li>
<li>SoundCloud</li>
<li>Canonical</li>
<li>CloudFlare</li>
<li>Mozilla</li>
<li>Hashicorp</li>
<li>...</li>
<li><a href="">http://golang.org/wiki/GoUsers</a></li>
</ul>
</section><section id="quem-usa-1" class="slide level2">
<h1>Quem usa?</h1>
<figure>
<img src="images/trends.png" alt="Google Trends" /><figcaption>Google Trends</figcaption>
</figure>
</section><section id="por-que-eu-gosto-de-go" class="slide level2">
<h1>Por que eu gosto de Go?</h1>
<ul>
<li>Simplicidade</li>
<li>Desempenho</li>
<li>Binários estáticos (facilita deploys)</li>
<li>Excelente biblioteca padrão</li>
<li>Orientada a objetos ??</li>
<li>Interfaces implicitas</li>
<li>Ferramentas
<ul>
<li>go build, got fmt, go test, go cover, ...</li>
</ul></li>
</ul>
</section><section id="o-que-não-é-tão-legal-ainda" class="slide level2">
<h1>O que não é tão legal (ainda)?</h1>
<ul>
<li>GC</li>
<li>Gerenciamento de dependências</li>
<li>Tratamento de erros</li>
</ul>
</section></section>
<section><section id="use-the-source-luke" class="titleslide slide level1"><h1>Use the source, Luke!</h1></section><section id="hello-world" class="slide level2">
<h1>Hello World!</h1>
<pre class="golang"><code>package main

import &quot;fmt&quot;

func main() {
    quem := &quot;Gurupi&quot;
    fmt.Printf(&quot;Fala galera do %s!\n&quot;, quem)
}</code></pre>
<pre class="sh"><code>go run hello.go</code></pre>
</section><section id="tipos" class="slide level2">
<h1>Tipos</h1>
<ul>
<li>Tipos primitivos</li>
</ul>
<pre><code>int, uint, int8, uint8, ...
bool, string
float32, float64
complex64, complex128</code></pre>
<ul>
<li>slices, arrays e maps</li>
</ul>
<pre><code>[]int, [3]string, []struct{ Name string }
map[string]int</code></pre>
<ul>
<li>structs</li>
</ul>
<pre class="golang"><code>type Proxy struct {
  httputil.ReverseProxy
  servers Servers
  tld     string
}</code></pre>
</section><section id="tipos-1" class="slide level2">
<h1>Tipos</h1>
<ul>
<li>pointers</li>
</ul>
<pre><code>*int, *Proxy</code></pre>
<ul>
<li>funções</li>
</ul>
<pre class="golang"><code>func AddrPort(addr string) (int, error)</code></pre>
<ul>
<li>channels</li>
</ul>
<pre><code>chan bool</code></pre>
<ul>
<li>interfaces</li>
</ul>
<pre class="golang"><code>type Server interface {
  Name() string
  Port() int
}</code></pre>
</section></section>
<section><section id="interfaces" class="titleslide slide level1"><h1>Interfaces</h1></section><section id="duck-typing" class="slide level2">
<h1>Duck typing</h1>
<ul>
<li>São implicitas</li>
</ul>
<pre class="golang"><code>// Interface do pacote `fmt`
type Stringer interface {
    String() string
}</code></pre>
<pre class="golang"><code>type server struct {
  name string
  port int
}
func (s *server) Name() string {
  return s.name
}
func (s *server) Port() int {
  return s.port
}
func (s *server) String() string {
  return fmt.Sprintf(&quot;%s:%d&quot;, s.name, s.port)
}</code></pre>
<pre class="golang"><code>  s := server{&quot;localhost&quot;, 3000}
  fmt.Printf(&quot;Started at %s\n&quot;, s)</code></pre>
</section><section id="composição-de-interfaces" class="slide level2">
<h1>Composição de interfaces</h1>
<pre class="golang"><code>package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Writer interface {
    Write(p []byte) (n int, err error)
}
type ReadWriter interface {
    Reader
    Writer
}</code></pre>
</section><section id="encadeamento-de-io.readers" class="slide level2">
<h1>Encadeamento de io.Readers</h1>
<pre class="golang"><code>package main

import (
    &quot;compress/gzip&quot;
    &quot;encoding/base64&quot;
    &quot;io&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

func main() {
    var r io.Reader
    r = strings.NewReader(data)
    r = base64.NewDecoder(base64.StdEncoding, r)
    r, _ = gzip.NewReader(r)
    io.Copy(os.Stdout, r)
}</code></pre>
</section><section id="programação-para-web" class="slide level2">
<h1>Programação para Web</h1>
<pre class="golang"><code>package main

import (
 &quot;log&quot;
 &quot;net/http&quot;
)

func Collector(w http.ResponseWriter, req *http.Request) {
  defer req.Body.Close()
  monit := MonitFromXml(req.Body)
  queue &lt;- &amp;monit
}

func main() {
    http.HandleFunc(&quot;/collector&quot;, Collector)
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}</code></pre>
</section><section id="http-handlers" class="slide level2">
<h1>Http handlers</h1>
<pre class="golang"><code>type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}</code></pre>
<pre class="golang"><code>type dogpack struct {}

func (h *dogpack) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // Processamento da requisição
}

func main() {
    http.Handle(&quot;/&quot;, &amp;dogpack{})
    log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}</code></pre>
</section><section id="http-handlerfunc" class="slide level2">
<h1>HTTP HandlerFunc</h1>
<pre class="golang"><code>type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}</code></pre>
</section><section id="compondo-funcionalidades" class="slide level2">
<h1>Compondo funcionalidades</h1>
<p>HTTP error handlers</p>
<pre class="golang"><code>type errorHandler func(http.ResponseWriter, *http.Request) error

func handleError(f errorHandler) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        err := f(w, r)
        if err != nil {
            log.Printf(&quot;%v&quot;, err)
            http.Error(w, &quot;Oops!&quot;, http.StatusInternalServerError)
        }
    }
}</code></pre>
</section><section id="http-error-handlers" class="slide level2">
<h1>HTTP error handlers</h1>
<pre class="golang"><code>func handler(w http.ResponseWriter, r *http.Request) error {
    name := r.FormValue(&quot;name&quot;)
    if name == &quot;&quot; {
        return fmt.Errorf(&quot;empty name&quot;)
    }
    fmt.Fprintln(w, &quot;Hi,&quot;, name)
    return nil
}</code></pre>
<pre class="golang"><code>http.HandleFunc(&quot;/form&quot;, handleError(handler))</code></pre>
</section></section>
<section><section id="concorrência" class="titleslide slide level1"><h1>Concorrência</h1></section><section class="slide level2">

<blockquote>
<p>Don't communicate by sharing memory. Instead, share memory by communicating.</p>
</blockquote>
</section><section id="concorrência-1" class="slide level2">
<h1>Concorrência</h1>
<ul>
<li>Goroutines e channels</li>
<li>Inspirada por CSP</li>
</ul>
</section><section id="goroutines" class="slide level2">
<h1>Goroutines</h1>
<ul>
<li>Não são threads</li>
<li>Muitas goroutines podem executar na mesma thread</li>
</ul>
<pre class="golang"><code>i := pivot(s)
go sort(s[:i])
go sort(s[i:])</code></pre>
</section><section id="channels" class="slide level2">
<h1>Channels</h1>
<ul>
<li>Servem para sincronização e comunicação entre goroutines</li>
<li>Operador <code>&lt;-</code> é utilizado para enviar e receber valores</li>
</ul>
<pre class="golang"><code>func compute(ch chan int) {
    ch &lt;- someComputation()
}

func main() {
    ch := make(chan int)
    go compute(ch)
    result := &lt;-ch
}</code></pre>
</section><section id="sincronização" class="slide level2">
<h1>Sincronização</h1>
<ul>
<li>(Un)buffered channels</li>
</ul>
<pre class="golang"><code>done := make(chan bool)
doSort := func(s []int) {
 sort(s)
 done &lt;- true
}

i := pivot(s)
go doSort(s[:i])
go doSort(s[i:])
&lt;-done
&lt;-done</code></pre>
</section><section id="comunicação" class="slide level2">
<h1>Comunicação</h1>
<pre class="golang"><code>type Work struct { x, y, z int }

func worker(in &lt;-chan *Work, out chan &lt;- *Work) {
    for w := range in {
        w.z = w.x * w.y
        out &lt;- w
    }
}

func Run() {
    in, out := make(chan *Work), make(chan *Work)
    for i := 0; i &lt; 10; i++ {
        go worker(in, out)
    }
    go sendLotsOfWork(in)
    receiveLotsOfResults(out)
}</code></pre>
</section></section>
<section><section id="workspace" class="titleslide slide level1"><h1>Workspace</h1></section><section id="ferramentas" class="slide level2">
<h1>Ferramentas</h1>
<ul>
<li>Compila e executa</li>
</ul>
<pre><code>go run hello.go</code></pre>
<ul>
<li>Executa os testes</li>
</ul>
<pre><code>go test</code></pre>
<ul>
<li>Gera binário e formata código</li>
</ul>
<pre><code>go build
go fmt</code></pre>
<ul>
<li>Baixa e instala dependências</li>
</ul>
<pre><code>go get github.com/jweslley/procker</code></pre>
</section><section id="organização-do-workspace" class="slide level2">
<h1>Organização do Workspace</h1>
<ul>
<li>Organizado automaticamente pelas ferramentas de build</li>
</ul>
<pre><code>workspace/
  bin # executable binaries
  pkg # compiled object files
  src # source code
    github.com/jweslley/
      procker/
</code></pre>
<pre class="golang"><code>import &quot;github.com/jweslley/procker&quot;</code></pre>
</section><section id="criando-um-workspace" class="slide level2">
<h1>Criando um workspace</h1>
<p>Crie o diretorio em local de preferência</p>
<pre><code>mkdir -p $HOME/gocode/src</code></pre>
<p>Exporte a variavel <code>GOPATH</code></p>
<pre><code>export GOPATH=$HOME/gocode</code></pre>
<p>Adicione o <code>GOPATH/bin</code> ao <code>PATH</code></p>
<pre><code>export PATH=$PATH:$GOPATH/bin</code></pre>
</section><section id="trabalhando-no-workspace" class="slide level2">
<h1>Trabalhando no workspace</h1>
<ul>
<li><p>Escolha um <em>namespace</em> <code>github.com/jweslley</code> no meu caso</p></li>
<li><p>Crie um diretório e programe alguma coisa</p></li>
</ul>
<pre><code>mkdir $GOPATH/src/github.com/jweslley/hello
cp hello.go $GOPATH/src/github.com/jweslley/hello</code></pre>
<ul>
<li>Crie e instale o binário</li>
</ul>
<pre><code>go install github.com/jweslley/hello</code></pre>
<ul>
<li>Execute-o</li>
</ul>
<pre><code>$GOPATH/bin/hello</code></pre>
</section><section id="mais-informações" class="slide level2">
<h1>Mais informações</h1>
<ul>
<li><a href="">http://golang.org/</a></li>
<li><a href="http://golang.org/doc/">Documentation</a></li>
<li><a href="http://tour.golang.org/">A Tour of Go</a></li>
<li><a href="https://play.golang.org/">Go playground</a></li>
<li><a href="http://golang.org/doc/code.html">How to Write Go Code</a></li>
<li><a href="http://golang.org/doc/effective_go.html">Effective Go</a></li>
<li><a href="https://gobyexample.com/">Go by example</a></li>
<li><a href="http://www.golangbootcamp.com/book/">Go Bootcamp book</a></li>
</ul>
</section><section id="obrigado" class="slide level2">
<h1>Obrigado!</h1>
<ul>
<li>Jonhnny Weslley</li>
<li><span class="citation" data-cites="jweslley">@jweslley</span></li>
<li><a href="">http://jweslley.github.io/talks/gurupi-golang</a></li>
</ul>
</section></section>
    </div>
  </div>


  <script src="../reveal.js/lib/js/head.min.js"></script>
  <script src="../reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
//          { src: '../reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: '../reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
    </body>
</html>
